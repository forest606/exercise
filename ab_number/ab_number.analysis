http://www.cnblogs.com/TenosDoIt/p/3496453.html

假设b的位数为kb, 集合L，R中所有元素的和分别为sumL、sumR，集合L，R中元素的个数分别为sizeL、sizeR。从题目所给的例子可以很容易的分析出最后的结果 = sumL * (10^(kb + 1)) * sizeR + sumR * sizeL （对1000000007求模）。所以我们的目标是求sumL、sizeL和sumR、sizeR。

一 求集合R：sumR、sizeR

我们假设a <= b (如果a > b 可以两者交换)，a的十进制位数为ka, b的十进制位数为kb。因此异或求解集合R中元素时，只有b的最后ka个二进制位受影响，b的前kb-ka个二进制位可以表示0…2^(kb-ka)-1的所有数。现在我们只考虑b的后面ka个二进制位：

1、假设b = 11001，a = 101，那么R = {00001…11001}^{001…101}表示的数有哪些呢？ 我们可以看到两者异或后可以表示的最大的数是11001^100 = 11101（注意到后三位异或能表示的最大为001^100 = 101）, 最小的数是00001^001 = 00000（注意到后三位异或能表示的最小为001^001 = 000），界于最大和最小的数之间的所有数都可以表示（这是因为后三位异或可以表示000~101之间的所有数）。

2、假设b = 11000，a = 101，那么R = {00001…11001}^{001…101}表示的数有哪些呢？ 我们可以看到两者异或后可以表示的最大的数是11001^100 = 11101（注意到后三位异或能表示的最大为001^100 = 101）, 最小的数是00001^001 = 00000（注意到后三位异或能表示的最小为001^001 = 000），界于最大和最小的数之间的所有数都是不是都可以表示呢，答案是否定的，b本身就不能表示(11000 = 11000^000, 但是题目中说明了y>=1,y不能等于0)。

3、那么什么时候R中不包括b呢：当b的后ka个二进制位全部为0时，b就不属于集合R

4、如何R中的最大元素，要求最大元素，就要使b的后ka个二进制位中1的个数最多，假设a = 10110101， b的后8位为backb = 00101101，注意到我们可以通过异或使backb从左边第三位(左起第一个1)起全部为1(即101101^010010 = 111111)，backb的前两位最大能表示00^10 = 10，因此a^backb最大为10111111。即选取b的后ka个二进制位backb，把backb左起第一个二进制位1开始全部置1，backb的其余为和a的对应位异或，这样得到的数就是R的最大值。

5、还需要注意一点是，如果a、b中有一个数为1，那么R中1就不属于集合R，因为1要和0异或才能得到1.

综上所述，我们可以根据步骤4求得R的最大值，那么R = {0，1,2…maxR}，然后根据步骤3和步骤5判断一下b和1是否要从R中剔除，求R的复杂度为O(32)（32为整数的位数）

 

二 求集合L：sumL，sizeL

最简单的就是枚举，用哈希表排除重复元素，但是这样时间复杂度为O(ab), 当b很大时，会超时。

注意到其实我们没有必要求出L中所有的元素，我们需要的是L中元素的个数和元素的和。同理假设a <= b

sumL =

1*{1,2,3…b} +

2*{1,2,3…b} +

…+

a*{1,2,3…b} - 重复的元素

假设集合Li = i * {1,2,3…b}, 注意到为避免重复元素，对于i，不用每次都从1开始乘, 至少可以从 i 开始即 Li = i *{i, i+1,…b}。我们还可以进一步缩小范围，假设i 素因子分解后 i = m * n * k，其中k是最小的素因子，那么我只要从max( b / k +1, i )开始乘，因为m*n*k*(b/k + 1) = m*n*b + i. 当i = m*n 时，m*n*b前面已经计算过，因此至少可以从m*n*b + i 开始计算。所以Li = i * {j, j+1, … ,b}, 其中j = max( b / minPrimeFactor(i)  + 1, i )   （ i = 1 时特别考虑）。

所以sumL = U( Li )， 其中（i = 1…a, U表示求集合的并集）。

求集合的并集，我们很容易想到容斥原理：



那么对于集合Lj …Lk的交集可以如下求：

先求j, j+1, …, k 的最小公倍数lcm，那么他们的交集 = lcm * {start…end}, 其中

start = ceil（max( max(b / minPrimeFactor(i) + 1, i ) ) / lcm），i = j…k  （即交集的最小元素 >= 所有集合的第一个元素的最大值）

end = j*b / lcm （即交集的最大元素 <= 第一个集合的最大元素）


如果a = 30我们就要求2^30-1次交集，注意到求交集的过程中很多为空集，比如L1∩L2 = 空集，因此L1∩L2∩L3就没必要求了，这样可以减去很多计算。可以通过dfs搜索+剪枝来求sumL，求的过程中我们也很容易求得sizeL。本文地址

 
三 求最终结果

通过公示 sumL * (10^(kb + 1)) * sizeR + sumR * sizeL （对1000000007求模）求最终结果

最后还需要注意的是，由于数据较大，用int会溢出，（我求最小公倍数时用int，这个错误找了好久）
